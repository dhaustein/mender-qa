#!/bin/sh

set -e
set -x

usage() {
    echo "Usage:"
    echo "  $0 --ensure <project-key> <build-name> <xml-file>"
    echo "  $0          <project-key> <build-name> <xml-file>"
    echo
    echo "Project keys:"
    echo "  accep_qemux86_64_uefi_grub"
    echo "  accep_vexpress_qemu"
    echo "  accep_qemux86_64_bios_grub"
    echo "  accep_qemux86_64_bios_grub_gpt"
    echo "  accep_vexpress_qemu_uboot_uefi_grub"
    echo "  accep_vexpress_qemu_flash"
    echo "  backend_integration_open_source"
    echo "  backend_integration_enterprise"
    echo "  full_integration"
    echo "  full_integration_enterprise"
    echo "  accep_qemux86_64_uefi_grub_cross_platform"
    exit 1
}

ensure=0
if [ "$1" = "--ensure" ]; then
    ensure=1
    shift
fi

# we need at least 3 args now (after reading `--ensure`` flag): project-key, build-name, and results xml-file
[ "$#" -lt 3 ] && usage

project_key=$1 ; shift  # human readable project name
build_name=$1  ; shift  # human-readable name (nightly-YYYY-MM-DD or pullreq-â€¦)
results_file=$1         # JUnit XML to upload

case "$project_key" in
    accep_qemux86_64_uefi_grub)                project_id=1  ;;
    accep_vexpress_qemu)                       project_id=2  ;;
    accep_qemux86_64_bios_grub)                project_id=3  ;;
    accep_qemux86_64_bios_grub_gpt)            project_id=4  ;;
    accep_vexpress_qemu_uboot_uefi_grub)       project_id=5  ;;
    accep_vexpress_qemu_flash)                 project_id=6  ;;
    backend_integration_open_source)           project_id=7  ;;
    backend_integration_enterprise)            project_id=8  ;;
    full_integration)                          project_id=9  ;;
    full_integration_enterprise)               project_id=10 ;;
    accep_qemux86_64_uefi_grub_cross_platform) project_id=11 ;;
    *)  echo "FATAL: unknown Mantra project key '$project_key'" >&2; exit 2 ;;
esac

API="https://qastatus.mender.io/api/ci/projects/${project_id}"
AUTH="-u ${MANTRA_USERNAME}:${MANTRA_PASSWORD}"

if [ "$ensure" -eq 1 ]; then
    # Try to find an existing build with that name
    build_id=$(curl -sSf $AUTH "${API}/builds?name=${build_name}&limit=1" |
               jq -r '.[0].id // empty')

    if [ -z "$build_id" ]; then
        # Not found; attempt to create (ignore errors if a parallel shard wins)
        build_id=$(curl -sSf -H "Content-Type: application/json" $AUTH \
                   -d "{\"name\":\"${build_name}\"}" \
                   "${API}/builds" 2>/dev/null |
                   jq -r .id || true)

        # If we lost the race, request again to get the id that now exists
        [ -z "$build_id" ] && build_id=$(curl -sSf $AUTH \
             "${API}/builds?name=${build_name}&limit=1" |
             jq -r '.[0].id')
    fi
else
    # Previous behaviour: always create a fresh build
    build_id=$(curl -sSf -H "Content-Type: application/json" $AUTH \
               -d "{\"name\":\"${build_name}\"}" \
               "${API}/builds" | jq -r .id)
fi

[ -z "$build_id" ] && { echo "Could not obtain build id"; exit 1; }

curl -fsS $AUTH \
     -H "Content-Type: application/xml" \
     --data-binary @"${results_file}" \
     "${API}/builds/${build_id}/results"
